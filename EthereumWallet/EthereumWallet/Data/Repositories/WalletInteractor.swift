//
//  WalletInteractor.swift
//  EthereumWallet
//
//  Created by Sharon Varghese on 25/03/2024.
//  Copyright (c) 2024 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol WalletBusinessLogic
{
    func startNetworkMonitring()
    func fetchWalletDetails(address: String)
}

protocol WalletDataStore
{
  //var name: String { get set }
}

class WalletInteractor: WalletBusinessLogic, WalletDataStore
{
    var presenter: WalletPresentationLogic?
    var apiManager = APIManager.shared
    
    func startNetworkMonitring() {
        NetworkManager.shared.startMonitoring()
    }
    func fetchWalletDetails(address: String) {
        if NetworkManager.shared.monitor.currentPath.status == .satisfied{
            fetchWalletDetailsFromServer(address: address)
        } else {
            fetchCachedData(address: address)
        }
        
    }
    
    func fetchWalletDetailsFromServer(address: String) {
        var viewModel = Wallet.Response()
        viewModel.walletAddress = address
        let group = DispatchGroup()
        
        group.enter()
        let balanceUseCase = FetchWalletBalanceUseCase(walletAddress: address, apiManager: apiManager)
        balanceUseCase.fetch { result in
            switch result {
            case .success(let balance):
                viewModel.walletBalance = balance
            case .failure(let failure):
                print("Fetch balance failed:: \(failure.localizedDescription)")
            }
            group.leave()
        }
        
        group.enter()
        let transactionsCountUseCase = FetchWalletTransactionsCountUseCase(walletAddress: address, apiManager: apiManager)
        transactionsCountUseCase.fetch { result in
            switch result {
            case .success(let count):
                viewModel.transacrtionCount = count
            case .failure(let failure):
                print("Fetch transaction count failed:: \(failure.localizedDescription)")
            }
            group.leave()
        }
        
        group.enter()
        let nftUseCase = FetchWalletNFTsUseCase(walletAddress: address, apiManager: apiManager)
        nftUseCase.fetch { result in
            switch result {
            case .success(let nfts):
                viewModel.nfts = nfts
            case .failure(let failure):
                print("Fetch NFTs  failed:: \(failure.localizedDescription)")
            }
            group.leave()
        }
        
        group.notify(queue: .main) { [weak self] in
            self?.saveToCoreData(details: viewModel)
            self?.presenter?.presentWalletDetails(response: viewModel)
        }
        
    }
    
    func fetchCachedData(address: String) {
        if let cacheData = FetchFromCacheUseCase().fetchWalletDetails() {
            self.presenter?.presentWalletDetails(response: cacheData)
        }
        
    }
    
    func saveToCoreData(details: Wallet.Response) {
        SaveToCacheUseCase().saveWalletDetails(response: details)
    }
    
    deinit {
        NetworkManager.shared.stopMonitoring()
    }
    
}
