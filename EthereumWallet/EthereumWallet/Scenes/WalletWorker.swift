//
//  WalletWorker.swift
//  EthereumWallet
//
//  Created by Sharon Varghese on 25/03/2024.
//  Copyright (c) 2024 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class WalletWorker
{
    func fetchTransactionsCount(walletAddress: String, completion: @escaping (Result<Int, Error>) -> Void) {
        let params = [walletAddress, "latest"]
        APIManager.shared.callAlchemyAPI(method: "eth_getTransactionCount", params: params) { result in
            switch result {
            case .success(let json):
                if let jsonDict = json as? [String: Any], let resultHex = jsonDict["result"] as? String {
                    // Convert hexadecimal string to integer
                    if let resultInt = Int(resultHex.dropFirst(2), radix: 16) {
                        completion(.success(resultInt))
                    } else {
                        completion(.failure(APIManager.APIError.invalidResponse))
                    }
                } else {
                    completion(.failure(APIManager.APIError.invalidResponse))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
    
 
    func fetchWalletBalance(walletAddress: String, completion: @escaping (Result<String, Error>) -> Void) {
        let params = [walletAddress, "latest"]
        APIManager.shared.callAlchemyAPI(method: "eth_getBalance", params: params) { result in
            switch result {
            case .success(let json):
                if let jsonDict = json as? [String: Any], let resultHex = jsonDict["result"] as? String {
                    // Convert hexadecimal balance to decimal
                    if let balance = self.convertHexToDecimal(resultHex) {
                        // Convert balance to Ether
                        let balanceInEther = (Double(balance) ?? 0.0) / 1_000_000_000_000_000_000
                        completion(.success("\(balanceInEther) Ether"))
                    } else {
                        completion(.failure(APIManager.APIError.invalidResponse))
                    }
                } else {
                    completion(.failure(APIManager.APIError.invalidResponse))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }

    func fetchWalletAddress(completion: @escaping (Result<String, Error>) -> Void) {
        APIManager.shared.callAlchemyAPI(method: "eth_accounts", params: []) { result in
            switch result {
            case .success(let json):
                if let jsonDict = json as? [String: Any], let resultArray = jsonDict["result"] as? [String], let hexAddress = resultArray.first, let decimalAddress = self.convertHexToDecimal(hexAddress) {
                    completion(.success(decimalAddress))
                } else {
                    completion(.failure(APIManager.APIError.invalidResponse))
                }
            case .failure(let error):
                completion(.failure(error))
            }
        }
    }
    
//    func fetchWalletNFTs(walletAddress: String, completion: @escaping (Result<[String], Error>) -> Void) {
//        // Call the balanceOf method of the ERC721 contract to get the number of NFTs owned by the wallet address
//        let balanceParams = [
//            [
//                "to": walletAddress,
//                "data": "0x70a08231000000000000000000000000" + walletAddress.dropFirst(2)
//            ],
//            "latest"
//        ] as [Any]
//        APIManager.shared.callAlchemyAPI(method: "eth_call", params: balanceParams) { result in
//            switch result {
//            case .success(let balanceJson):
//                guard let balanceHex = (balanceJson as? [String: Any])?["result"] as? String else {
//                    completion(.failure(APIManager.APIError.invalidResponse))
//                    return
//                }
//                // Convert balanceHex to integer to get the number of NFTs owned by the wallet address
//                guard let balance = Int(balanceHex.dropFirst(2), radix: 16) else {
//                    completion(.failure(APIManager.APIError.invalidResponse))
//                    return
//                }
//
//                // Iterate over the NFT IDs to get the metadata URI for each NFT
//                var nftURIs: [String] = []
//                for i in 0..<balance {
//                    let tokenURIParams = [
//                        [
//                            "to": "0x" + contractAddress, // ERC721 contract address
//                            "data": "0x6352211e" + String(format: "%064x", i) // tokenURI selector + NFT ID
//                        ],
//                        "latest"
//                    ]
//                    APIManager.shared.callAlchemyAPI(method: "eth_call", params: tokenURIParams) { result in
//                        switch result {
//                        case .success(let tokenURIJson):
//                            if let tokenURIHex = (tokenURIJson as? [String: Any])?["result"] as? String, let tokenURI = String(bytes: (BigInt(tokenURIHex.dropFirst(2), radix: 16) ?? BigInt(0)).bytes, encoding: .utf8) {
//                                nftURIs.append(tokenURI)
//                                if nftURIs.count == Int(balance) {
//                                    completion(.success(nftURIs))
//                                }
//                            } else {
//                                completion(.failure(APIManager.APIError.invalidResponse))
//                            }
//                        case .failure(let error):
//                            completion(.failure(error))
//                        }
//                    }
//                }
//            case .failure(let error):
//                completion(.failure(error))
//            }
//        }
//    }


    
    func convertHexToDecimal(_ hex: String) -> String? {
        var result: UInt64 = 0
        let scanner = Scanner(string: hex)
        scanner.scanLocation = 2 // Skip "0x" prefix
        guard scanner.scanHexInt64(&result) else {
            return nil
        }
        return "\(result)"
    }


}
